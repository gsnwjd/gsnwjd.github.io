<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="&amp;nbsp;&amp;nbsp;——本文允许转载,分享请注明网站出处: ）前端一些面试经常碰到的题js基本数据类型undefined,null,boolean,string,numberObject,Array,Function属于引用类型typeof null返回为object,因为特殊值null被认为是">
    

    <!--Author-->
    
        <meta name="author" content="gsnwjd王佳典">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="面试总结 : 一些细碎的知识点">
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="嗯哼~">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>面试总结 : 一些细碎的知识点 - 嗯哼~</title>

    <!-- Tachyons Core CSS -->
    <link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<div class="w-100 bg-1 ph5-ns ph3 text-light">
    
    <nav class="db dt-l w-100 mw8 center border-box pv3">
        <a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="嗯哼~">
            <img src="http://www.codeblocq.com/assets/projects/hexo-theme-anodyne/assets/anodyne.svg" class="dib h3" alt="嗯哼~">
        </a>
        <div class="db dtc-l v-mid w-100 w-75-l tc tr-l">
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">
                    Home
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">
                    Archives
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">
                    Tags
                </a>
            
        </div>
    </nav>

    <!-- Title -->
    <div class="w-100 mw8 center vh-40 dt">
        <div class="dtc v-mid white">
            <h1 class="f1-l f2-m tc tc-m tl-ns">面试总结 : 一些细碎的知识点</h1>
            <p class="f4 fw3 pab-100px tc tc-m tl-ns">2020-08-25</p>
        </div>
    </div>

    <!-- Icon -->
    <div class="relative w-100 mw8 center white dn dn-m db-ns">
        <i class="header-icon fa fa-meh-o"></i>
    </div>
</div>

<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content">
                    <!-- Tags Vertical -->
                    
                        <div class="tags-container-vertical">
                            <div class="tags-sub-container">
                                <a class="fw3 ph1 dib" href="/tags/学不完的js/">#学不完的js</a>
                            </div>
                        </div>
                    

                    <!-- Main Post Content -->
                    <p><span style="color:#8c8c8c;border-left:4px solid #ff8453;">&nbsp;&nbsp;——本文允许转载,分享请注明网站出处: ）</span><br><br><span style="color:#a7c73f;">前端一些面试经常碰到的题</span></p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">js基本数据类型</p>undefined,null,boolean,string,number<br>Object,Array,Function属于引用类型<br>typeof null返回为object,因为特殊值null被认为是一个空的对象引用。<br>ES6新增基础类型:Symbol。新增引用类型:Set,Map,WeakMap,WeakSet<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;); // false</span><br><span class="line">var sym = new Symbol(); // TypeError</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">new一个对象的时候发生了什么？</p>1.创建一个新对象<br>2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象）;<br>3.一个新的对象被创建，同时继承了对象类型的原型，即prototype。new Array()就继承了Array.prototype。<br>4.执行构造函数中的代码（为这个新对象添加属性）<br>5.返回新对象。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Map,Set</p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。<br>NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的。（NaN被认为是相同的，尽管 NaN !== NaN）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let mySet = new Set()</span><br><span class="line">let o = &#123;a:1&#125;</span><br><span class="line">mySet.add(o);</span><br><span class="line">mySet.add(5)</span><br><span class="line">console.log(mySet.has(o),mySet.has(&#123;a:1&#125;))// true false</span><br><span class="line">// Set 和 Array互换</span><br><span class="line">mySet2 = new Set([1, 2, 3, 4]);</span><br><span class="line">mySet2.size;               // 4</span><br><span class="line">[...mySet2];               // [1,2,3,4]</span><br><span class="line"></span><br><span class="line">//求交集</span><br><span class="line">let intersection = new Set([...set1].filter(x =&gt; set2.has(x)));</span><br><span class="line">//求差集</span><br><span class="line">let difference = new Set([...set1].filter(x =&gt; !set2.has(x)));</span><br></pre></td></tr></table></figure><br>Map映射表,一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。<br>Map可以设置get,set。存储值。<br>一些通用的api:clear(),entries(),has(),values(),forEach(),size<br>Map独有:set(),get(),keys()。<br>Set独有:add()<p></p>
<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">url-&gt;页面</p>DNS域名解析-&gt;TCP连接-&gt;发送HTTP请求-&gt;服务器返回数据-&gt;渲染页面(同时HTML解析成DOM，CSS解析成CSSOM-&gt;组合在一起生成渲染树，画出页面)-&gt;连接结束<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Get,Post的区别</p>1.GET在浏览器回退时是无害的，而POST会再次提交请求。<br>2.GET产生的URL地址可以被Bookmark，而POST不可以。<br>3.GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>4.GET请求只能进行url编码，而POST支持多种编码方式。<br>5.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>6.GET请求在URL中传送的参数是有长度限制的，而POST没有。<br>7.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>8.GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>9.GET参数通过URL传递，POST放在Request body中。<br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">居中</p>margin:0px auto;<br>flex居中:父元素设置为（display: flex;flex-direction: column;align-items: center;）<br>父元素text-align:center;子元素为inline-block;<br>上下居中主要靠margin计算/父元素设置行高与高一样/position计算（css calc属性）<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">常用的一些代码段（一行溢出省略，两行溢出省略）</p>一行：overflow: hidden;text-overflow: ellipsis;white-space: nowrap;<br>两行或多行：overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">call,apply,bind的区别</p>call,apply,bind的主要作用都是改变this指向。<br>call和apply的主要区别是在传递参数上不同.<br>call后面传递的参数是以逗号的形式分开的，apply传递的参数是数组形式（apply是以A开头，所以这里可以跟Array有关联，即参数为数组）bind返回的是一个函数形式，如果要执行，则后面要再加一个小括号，例如：bind（obj,参数1，参数2）（），bind只能以逗号分隔形式，不能是数组形式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const module2 = &#123;</span><br><span class="line">  x: 42,</span><br><span class="line">  getX: function(...other) &#123;</span><br><span class="line">    console.log(this.x+&apos;/&apos;+other.join(&apos;/&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const resetX = &#123;</span><br><span class="line">  x:22</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module2.getX.call(resetX,&apos;传参1&apos;,&apos;传参2&apos;) // 22/传参1/传参2</span><br><span class="line">module2.getX.bind(resetX,&apos;传参1&apos;,&apos;传参2&apos;)() // 22/传参1/传参2</span><br><span class="line">module2.getX.apply(resetX,[&apos;传参1&apos;,&apos;传参2&apos;]) // 22/传参1/传参2</span><br></pre></td></tr></table></figure><br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">父传子值，子值不随父值改变</p>监听传值，仍使用旧值。<br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">jQuery实现数据双向绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; data-bind-0=name /&gt;</span><br><span class="line">    &lt;span data-bind-0=&quot;name&quot; &gt;&lt;/span&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> </span><br><span class="line">  function DataBinder(object_id)&#123;</span><br><span class="line">      let pubSub = jQuery(&#123;&#125;);</span><br><span class="line">      let data_attr = &quot;bind-&quot;+object_id,</span><br><span class="line">          message = object_id+&quot;:change&quot;;</span><br><span class="line">      jQuery(document).on(&quot;change&quot;,&quot;[data-&quot; + data_attr +&quot;]&quot;,function(evt)&#123;</span><br><span class="line">          let $input = jQuery(this);</span><br><span class="line">          pubSub.trigger(message, [$input.attr(&quot;data-&quot; + data_attr), $input.val()]);//触发事件</span><br><span class="line">        &#125;);</span><br><span class="line">      pubSub.on(message, function(evt,prop_name,new_val)&#123;</span><br><span class="line">          jQuery(&quot;[data-&quot; + data_attr + &quot;=&quot; + prop_name + &quot;]&quot;).each(function()&#123;</span><br><span class="line">              let $bound = jQuery(this);</span><br><span class="line">                if($bound.is(&quot;input,textarea,select&quot;)) &#123;</span><br><span class="line">                    $bound.val(new_val);</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    $bound.html(new_val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        return pubSub;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function User(uid)&#123;</span><br><span class="line">        let binder = new DataBinder(uid),</span><br><span class="line">            user = &#123;</span><br><span class="line">                attributes: &#123;&#125;,</span><br><span class="line">                set: function(attr_name,val)&#123;</span><br><span class="line">                    this.attributes[attr_name] = val;</span><br><span class="line">                    binder.trigger(uid + &quot;:change&quot;, [attr_name, val, this]);</span><br><span class="line">                &#125;,</span><br><span class="line"> </span><br><span class="line">                get: function(attr_name)&#123;</span><br><span class="line">                    return this.attributes[attr_name];</span><br><span class="line">                &#125;,</span><br><span class="line">                _binder: binder</span><br><span class="line">            &#125;;</span><br><span class="line">       </span><br><span class="line">          return user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    let user = new User(0);</span><br><span class="line">    user.set(&quot;name&quot;,&quot;text&quot;);</span><br><span class="line">    </span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">mvvm定义&amp;&amp;原理</p>Mvvm定义MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">模型</span> 指的是后端传递的数据。  <span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">视图</span> 指的是所看到的页面。<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">视图模型</span>mvvm模式的核心，它是连接view和model的桥梁。<br>它有两个方向：一是将<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">模型</span> 转化成<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">视图</span>,即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。<br>二是将<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">视图</span> 转化成<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">模型</span>,即将所看到的页面转化成后端的数据。实现的方式是<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">DOM 事件监听</span><br>。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个<span style="color:rgb(126, 85, 66);font-style:italic;font-weight: bolder;">observer观察者</span><br>，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<p style="color:#ffb453bb;font-weight:bold">onready和onload</p><span style="color:rgb(153, 138, 131);font-size:15px;font-weight:bold;">&gt;&gt;因为页面中的代码一般情况下按照，从上到下，从左到右的顺序执行。<br>    所以当js代码需要获取页面中的元素时，如果script标签在元素的前面，需要加window.onload；如果script放在了元素后面，就不需要加 window.onload。</span><br><span style="color:rgb(153, 138, 131);font-size:15px;font-weight:bold;">&gt;&gt;jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。<br><span style="color:rgb(153, 138, 131);font-size:15px;font-weight:bold;">&gt;&gt;onready比onload先执行,执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</span><br><span style="color:rgb(153, 138, 131);font-size:15px;font-weight:bold;">&gt;&gt;onload只执行最后一个而onready可以执行多个。</span></span><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">浅拷贝，深拷贝</p><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">1</span>浅拷贝就是拷贝了一层，除了对象是拷贝的引用类型，其他都是直接将值传递，有自己的内存空间的。<br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">2</span>Object.assign方法，Object.assign是ES6的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。说是可以拷贝深一层，如果对象只有一层的话，可以使用这个函数作为深拷贝的方法<br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">3</span>JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">数组去重 &amp;&amp; 对象合并</p>需要额外空间存放：定义一个空的新数组，遍历传入的数组，有就跳过，没有就存入/Array.from(new Set(arr))<br>不需要额外空间:写函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//排序再遍历，这一个是否与下一个相同,是就原地删除</span><br><span class="line">arr.sort((a,b)=&gt;&#123;</span><br><span class="line">  return a-b</span><br><span class="line">&#125;)</span><br><span class="line">for(let i = arr.length;i&gt;=0;i--)&#123;</span><br><span class="line">if(arr[i] === arr[i+1])&#123;</span><br><span class="line">  arr.splice(i,1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//排序,然后用reduce传一个空数组进行迭代，每次取末尾元素与当前元素比较，不同就推入pre</span><br><span class="line">let arr = this.testRepeat</span><br><span class="line">      return arr.sort((a,b)=&gt;&#123;return a-b&#125;).reduce((prev,cur)=&gt;&#123;</span><br><span class="line">          if(prev.length)&#123;</span><br><span class="line">            let before = prev[prev.length-1]</span><br><span class="line">            before !== cur?prev.push(cur):&apos;&apos;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            prev.push(cur)</span><br><span class="line">          &#125;</span><br><span class="line">          return prev;</span><br><span class="line">      &#125;,[])</span><br></pre></td></tr></table></figure>对象合并:Object.assign(obj1,obj2)/定义一个空对象,for in 一下两个对象。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">冒泡（定义&amp;&amp;阻止冒泡）,捕获</p><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">1</span>原生script里阻止冒泡<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//如果事件绑定在a标签上</span><br><span class="line">function bindEle(e,type,fn)&#123;</span><br><span class="line">  e.addEventListener(type,fn)</span><br><span class="line">&#125;</span><br><span class="line">var a = document.getElementById(&apos;link1&apos;)</span><br><span class="line">bindEle(a,&apos;click&apos;,function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&apos;clicked&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">//如果事件绑定在除了a标签之外的标签上</span><br><span class="line">function bindEle(e,type,fn)&#123;</span><br><span class="line">  e.addEventListener(type,fn)</span><br><span class="line">&#125;</span><br><span class="line">var a = document.getElementById(&apos;link1&apos;)</span><br><span class="line">bindEle(a,&apos;click&apos;,function(e)&#123;</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">  console.log(&apos;clicked&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">2</span>Vue里阻止冒泡<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; @click.prevent=&quot;test()&quot;&gt;阻止a标签默认&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;&quot; @click.prevent.stop=&quot;test()&quot;&gt;阻止a标签默认并且不冒泡&lt;/a&gt;</span><br><span class="line">&lt;span href=&quot;&quot; @click.stop=&quot;test()&quot;&gt;阻止冒泡触发父级事件&lt;/span&gt;</span><br></pre></td></tr></table></figure><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">3</span>事件捕获是先由最上一级的节点先接收事件，然后向下传播到具体的节点。当用户点击了div元素，采用事件捕获，则click事件将按照document—&gt;html—&gt;body—&gt;div的顺序进行传播。若在div和body上都定义了click事件，点击div，将先触发点击body事件，再触发点击div的事件<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">relative是相对定位，相对于什么？</p>相对于父级，即使父级元素是position:absolute;也同样起效。假设父元素没有设置position,子元素绝对定位，则它的相对位置会往外找直到找到position为relative的元素，如果没有，就是相对于body。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue生命周期</p>创建，挂载，更新，销毁。<br>我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init，在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。<br>当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数<br>beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。
<table>
<tr>
	<td></td>
	<td>是否获取DOM</td>
	<td>是否可以获取data</td>
	<td>是否获取methods</td>
</tr>
<tr>
	<td>beforeCreate</td>
	<td>否</td>
	<td>否</td>
	<td>否</td>
</tr>
<tr>
	<td>created</td>
	<td>否</td>
	<td>是</td>
	<td>是</td>
</tr>
<tr>
	<td>beforeMount</td>
	<td>否</td>
	<td>是</td>
	<td>是</td>
</tr>
<tr>
	<td>mounted</td>
	<td>是</td>
	<td>是</td>
	<td>是</td>
</tr>
</table>
<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue中父子组件生命周期</p>先父组件create初始化创建js模型，然后子组件创建js模型<br>子组件渲染完之后，父组件再渲染<br>创建实例是从外到内的，渲染是从内到外的<br>加载渲染：<br>父beforeCreate —&gt; 父created —&gt; 父beforeMount —&gt; 子beforeCreate —&gt; 子created —&gt; 子beforeMount —&gt; 子mounted —&gt; 父mounted<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue响应式原理</p>响应式是指视图渲染的时候使用了数据，数据改变后视图也会自动更新。<br>Vue的响应式，核心是观察者模式。Vue源码里，首先是函数 observe()让传入的整个对象成为响应式的，它会遍历对象的所有属性，然后执行defineReactive()，主要是造一个dep对象与当前数据对应，也就是data-&gt;dep-&gt;watcher这样记录依赖关系。通过Object.defineProperty重新定义对象属性，配置属性的set/get，从而数据被获取，设置的时候可以执行vue的代码。<br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">1</span>通过 Object.defineProperty() 替换配置对象属性的 set、get 方法，实现“拦截”<br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">2</span>watcher 在执行 getter 函数时触发数据的 get 方法，从而建立依赖关系<br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">3</span>写入数据时触发 set 方法，从而借助 dep 发布通知，进而 watcher 进行更新<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vuex</p>vuex数据传递的流程<br>当组价需要修改state中的数据的时候必须通过dispatch来触发actions里面的方法，actions的每一个方法里面都会有一个commit方法，用来触发mutations里面的方法, mutations用来修改state中的数据。当mutations里面的方法触发的时候数据就会发生改变，因为数据是响应式因此组件中的数据也会发生改变。<br>在vuex中必须遵循单项数据流。<br>state存储数据，actions里写一些数据获取和处理，mutations里写操作去修改state，getters写方法获取到最新的state数据(类似computed属性),modules做模块的划分(每一个模块又分成这5个部分)。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">如何解决跨域请求？</p>常用jsonp和CORS。<br>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。浏览器发出跨域请求的时候，会在header里添加一个Origin字段，服务器会返回一个正常的http回应，如果http回应的头里没有包含Access-Control-Allow-Origin这个字段，请求会抛出一个错误，onerror可以捕获到这个错误，但是这种错误无法通过状态码知晓。如果Origin指定的域名在许可范围内，服务器会返回Access-Control-Allow-Origin,Access-Control-Allow-Crentials,Access-Control-Expose-Headers这些字段。<br>同时我们请求接口的时候，必须在AJAX请求中打开withCredentials属性。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue的proxy是怎么实现的？</p>proxyTable原理:proxyTable 是 vue-cli 脚手架在开发模式下,为我们提供的一个跨域的代理中转服务器服务.基于 (http-proxy-middleware插件)。<blockquote><p>在开发模式下,webpack 会为我们提供一个http代理服务器。我们请求接口的时候,实际上是请求的webpack提供的这个http代理服务器。在由这个代理服务器请求真是的数据服务器.<br>最后数据经由webpack代理服务器,最后转交给我们的vue程序.</p>
</blockquote><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">作用域链&amp;&amp;闭包</p>作用域:限制变量有效的范围就叫作用域<br>ES5只有全局作用域和函数作用域,没有块级作用域.即使用{}包裹，外面也能访问里面的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var b = &apos;233&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(b)//&apos;233</span><br><span class="line">&#123;</span><br><span class="line">  let a = &apos;222&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)//a不存在</span><br></pre></td></tr></table></figure>ES6的let和const正是为了解决这个问题,let定义变量,const定义常量，这两个定义的变量都是块级作用域。<br>作用域链:函数在执行的过程中，先从自己内部找变量，如果找不到，再从创建当前函数所在的作用域去找, 以此往上。<br>在动态作用域的规则下，a 的引用不再是编译时确定，而是调用时确定的。<br>闭包定义:函数f1中定义了函数f2，f2引用了f1嵌套作用域内的变量x，并且f1将函数f2作为返回对象进行返回。最值得注意的是我们通过变量action获取了返回的f2，虽然此时f1函数已经退出结束了，但是f2仍然记住了f1嵌套作用域内的变量名x。上面这种语言现象称之为闭包：一个能记住嵌套作用域变量值的函数，尽管作用域已经不存在。嵌套作用域特殊之处:本地作用域在函数结束后就立即失效，而嵌套作用域在嵌套的函数返回后却仍然有效。<br>闭包是为了不污染变量,vue的data就是闭包的经典案例。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">v-model如何实现?</p>v-model其实就是一个由属性和事件组成的语法糖，例子——<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;变量&quot;&gt;</span><br><span class="line">等价于</span><br><span class="line">&lt;input type=&quot;text&quot; :value=&quot;变量&quot; @input=&quot;变量=$event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>具体如下表：
<table>
<tr>
	<td>元素</td>
	<td>属性</td>
	<td>事件</td>
</tr>
<tr>
	<td>input[type=text]、textarea</td>
	<td>value</td>
  	<td>input</td>
</tr>
<tr>
	<td>input[checkbox]、input[radio]</td>
	<td>checked</td>
	<td>change</td>
</tr>
<tr>
	<td>select</td>
	<td>value</td>
	<td>change</td>
</tr>
</table>
<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue.$nextTick</p>当你设置vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。<br>定义的三个重要变量:<br>callbacks:用来存储所有需要执行的回调函数。<br>pending:用来标志是否正在执行回调函数<br>timerFunc:用来触发执行回调函数<br>(先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数;<br>否则，如果支持MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。<br>如果都不支持，则利用setTimeout设置延时为0。)<br>MutationObserver()用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .i&#123;</span><br><span class="line">      color: aquamarine;</span><br><span class="line">  &#125;</span><br><span class="line">  .ii&#123;</span><br><span class="line">      color: blueviolet;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;some-id&quot; class=&quot;ii&quot; value=&quot;before&quot; name=&quot;inp1&quot;/&gt;</span><br><span class="line">&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 选择需要观察变动的节点</span><br><span class="line">const targetNode = document.getElementById(&apos;some-id&apos;);</span><br><span class="line"></span><br><span class="line">// 观察器的配置（需要观察什么变动）</span><br><span class="line">const config = &#123; attributes: true, childList: true, subtree: true &#125;;</span><br><span class="line"></span><br><span class="line">// 当观察到变动时执行的回调函数</span><br><span class="line">const callback = function(mutationsList, observer) &#123;</span><br><span class="line">for(let mutation of mutationsList) &#123;</span><br><span class="line">  if (mutation.type === &apos;childList&apos;) &#123;</span><br><span class="line">      console.log(&apos;A child node has been added or removed.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (mutation.type === &apos;attributes&apos;) &#123;</span><br><span class="line">      console.log(&apos;The &apos; + mutation.attributeName + &apos; attribute was modified.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个观察器实例并传入回调函数</span><br><span class="line">const observer = new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">// 以上述配置开始观察目标节点</span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">document.getElementById(&apos;some-id&apos;).value = &apos;测试&apos;</span><br><span class="line">document.getElementById(&apos;some-id&apos;).className = &apos;i&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 之后，可停止观察</span><br><span class="line">// observer.disconnect();</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//测试后出现:The class attribute was modified.</span><br></pre></td></tr></table></figure><br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue.extend用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var todoItem = Vue.extend(&#123;</span><br><span class="line">  template:`&lt;div class=&quot;show_test4&quot;&gt;面试总结 : 一些细碎的知识点&lt;/div&gt;`,</span><br><span class="line">  props:&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      default:()=&gt;&#123;return &apos;默认&apos;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//可注册成为全局组件</span><br><span class="line">Vue.component(&apos;testa&apos;,todoItem)</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue事件总线（EventBus使用介绍）</p>如果两个页面没有任何引入与被引入关系，用eventbus可以通信。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">var Eventbus = new Vue()</span><br><span class="line">Object.defineProperties(Vue.prototype,&#123;</span><br><span class="line">  $bus:&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">      return Eventbus;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//a.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendMessage()&quot;&gt;a按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">      sendMessage()&#123;</span><br><span class="line">          this.$bus.$emit(&apos;aMsg&apos;,&apos;来自a页面的消息&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//b.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">          msg:&apos;测试测试&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">      this.$bus.$on(&apos;aMsg&apos;,(msg)=&gt;&#123;</span><br><span class="line">          this.msg = msg</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">用==,&gt;,&lt;比较的时候会产生类型转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">undefined == 0</span><br><span class="line">//false</span><br><span class="line">undefined &lt; 0</span><br><span class="line">//false</span><br><span class="line">NaN === NaN</span><br><span class="line">//false</span><br><span class="line">undefined === null</span><br><span class="line">//false</span><br><span class="line">undefined == null</span><br><span class="line">//true</span><br><span class="line">0 == null</span><br><span class="line">//false</span><br><span class="line">1 == &apos;1&apos;</span><br><span class="line">//true</span><br><span class="line">5&gt;&apos;1&apos;</span><br><span class="line">//true</span><br><span class="line">2&gt;&apos;3&apos;</span><br><span class="line">//false</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">哪些变量不能放data里?&nbsp;&nbsp;computed和watch的区别?</p>    computed 是计算属性，它会根据你所依赖的数据动态显示新的计算结果，计算属性将被加入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例,通过计算出来的属性不需要调用直接可以在 DOM 里使用。页面中使用大量复杂的逻辑表达式处理数据时，会对页面的可维护性造成很大的影响,而且计算属性如果依赖不变的话，它就会变成缓存，computed 的值就不会重新计算,所以，如果数据要通过复杂逻辑来得出结果，那么就推荐使用计算属性<br>watch是一个对象，Vue 实例将会在实例化时调用$watch()，遍历 watch 对象的每一个属性，不应该使用箭头函数来定义 watcher 函数，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例<br>如果一个数据需要经过复杂计算就用 computed/如果一个数据需要被监听并且对数据做一些操作就用 watch<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">promise是异步还是同步？让你写一个函数，b依赖a的返回，c依赖b的返回</p>promise构造函数是同步执行的，then方法是异步执行的<br>直接用async/await<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">常见vue指令,vue如何自定义指令？</p>常见:v-show,v-if,v-text,v-html,v-bind(:),v-on(@),v-for,v-model,v-cloak(设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除),v-pre(跳过这个元素和它的子元素的编译过程。一些静态的内容不需要编辑加这个指令可以加快编辑)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;input v-focus&gt;</span><br><span class="line">  </span><br><span class="line">//复杂例子,选项高光</span><br><span class="line">Vue.directive(&apos;nav&apos;,&#123;</span><br><span class="line">  bind(el,binding)&#123;</span><br><span class="line">    const _oops = binding.value</span><br><span class="line">    console.log(_oops)</span><br><span class="line">    const _c = el.getElementsByClassName(_oops.className)</span><br><span class="line">    console.log(_c[0].className)</span><br><span class="line">    _c[_oops.curIndex].className+=` $&#123;_oops.activeClass&#125;`</span><br><span class="line">  &#125;,</span><br><span class="line">  update(el,binding)&#123;</span><br><span class="line">    console.log(&apos;update!!!&apos;)</span><br><span class="line">    const _oops = binding.value</span><br><span class="line">    const _oops2 = binding.oldValue</span><br><span class="line">    const _c = el.getElementsByClassName(_oops.className)</span><br><span class="line">    _c[_oops2.curIndex].className = `$&#123;_oops.className&#125;`</span><br><span class="line">    _c[_oops.curIndex].className+=` $&#123;_oops.activeClass&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//vue</span><br><span class="line">&lt;ul class=&quot;row2-left&quot; v-nav=&quot;&#123;curIndex:cur,className:&apos;test&apos;,activeClass:&apos;choose&apos;&#125;&quot; &gt;</span><br><span class="line">                    &lt;li v-for=&quot;(item,idx) in $store.state.course.maplist&quot; </span><br><span class="line">                        :key=&quot;idx&quot; </span><br><span class="line">                        @mouseenter=&quot;change($event,idx)&quot; </span><br><span class="line">                        @click=&quot;change($event,idx)&quot; </span><br><span class="line">                        class=&quot;test&quot;&gt;</span><br><span class="line">                        </span><br><span class="line">                    &lt;i :class=&quot;item.addr&quot;/&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">//methods</span><br><span class="line">change:function(e,idx)&#123;</span><br><span class="line">            this.cur = idx</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">vue属性覆盖</p>computed&gt;methods&gt;props&gt;data<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">页面性能优化 &amp;&amp; SEO优化 &amp;&amp; Web安全</p>页面性能优化：减少前端资源数量，减小前端资源大小，减少dom操作。<br>代码层面：注意事件的销毁、路由懒加载、提取公共代码、css放前面、组件懒加载、减少代码体积大小、字体图标代替图片、使用事件委托、使用查找表、不覆盖原生方法、减低css选择器复杂度、使用flex、使用 transform 和 opacity实现动画。<br>交互优化：减少请求数量、使用 HTTP2（头部压缩、链路复用、解析快、可设置优先级、流量控制、服务器推送）、减少重绘重排（innerHTML代替DOM操作、避免使用动态属性、脱离文档流操作再合并）。加载优化：按需引入、使用CDN、使用服务端渲染。打包优化：使用gzip、Webpack 对图片进行压缩、webpack 按需加载代码、提取第三库代码、webpack物理打包以及配置项打包优化。其他优化：图片优化（压缩、用webp格式，延迟加载）少用全局变量<br><br>SEO优化:静态化/预渲染/语义化的HTML代码，符合W3C规范/非装饰性图片必须加alt/向各大搜索引擎提交收录自己的站点/重要的内容放在前面/少用iframe/提高网站速度：这也是搜索引擎排序的一个重要指标/流量<br><br>Web安全:对用户的输入进行校验，可以通过正则表达式或限制长度；对单引号和双”-“进行转换等/不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取/每个应用使用单独的权限有限的数据库连接。不要把机密信息直接存放，加密或者Hash掉密码和敏感的信息。<br>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装/SQL注入的检测方法一般采取辅助软件或网站平台来检测/使用HTTPS/机密性：混合算法/同时引入第三方证书机构，确保公开秘钥的安全性<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let res = []</span><br><span class="line">function FJ(num)&#123;</span><br><span class="line">    let i = 2</span><br><span class="line">    if(num===2 || num===3 || num===1)&#123;</span><br><span class="line">        res.push(num)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(;i&lt;=num/2;i++)&#123;</span><br><span class="line">            if(num%i === 0)&#123;</span><br><span class="line">                res.push(i)</span><br><span class="line">                FJ(num/i)</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&gt;num/2)&#123;</span><br><span class="line">        res.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(FJ(390))</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">数组摊平</p><span style="color:#a7c73f;">数组拍平也称数组扁平化，就是将数组里面的数组打开，最后合并为一个数组</span><br><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">1</span>子数组只有一层就用flat函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var aaa = [1,2,3,[2,4]].flat(1);aaa</span><br><span class="line">//输出</span><br><span class="line">[ 1, 2, 3, 2, 4 ]</span><br></pre></td></tr></table></figure><span style="font-size:10px;padding:5px;color:#fff;border-radius: 50%;background-color: #ccffcc;">2</span>有两层的话用ES6的reduce函数（累加函数）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(arr)&#123;</span><br><span class="line">  return arr.reduce((prev,cur)=&gt;&#123;</span><br><span class="line">      return prev.concat(Array.isArray(cur)?fn(cur):cur)</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn([1,2,3,[2,0,[2,&apos;a&apos;,&#123;&apos;a&apos;:&apos;b&apos;&#125;],4]]))</span><br><span class="line">//输出</span><br><span class="line">[ 1, 2, 3, 2, 0, 2, &quot;a&quot;, &#123;&apos;a&apos;:&apos;b&apos;&#125;, 4 ]</span><br></pre></td></tr></table></figure>或者写个原生递归函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(arr)&#123;</span><br><span class="line">  var arr2 = []</span><br><span class="line">  for(var i in arr)&#123;</span><br><span class="line">    (arr[i] instanceof Array)?arr2 = arr2.concat(fn(arr[i])):arr2.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return arr2</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn([1,2,3,[2,0,[2,&apos;a&apos;,&#123;&apos;a&apos;:&apos;b&apos;&#125;],4]]))</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Less语法</p>见这篇博文<a style="color:#c7a73f;font-size:15px;" href="https://gsnwjd.github.io/2021/12/27/%E4%B8%80%E5%B0%8F%E6%97%B6%E8%81%8A%E5%AE%8CLess/">一小时聊完less</a><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">gulp和webpack的使用以及各自的优缺点</p>gulp核心：任务定义和组织/基于文件 stream 的构建/插件体系<br>webpack核心：按照模块的依赖构建目标文件/loader 体系支持不同的模块/插件体系提供更多额外的功能；<br>除了前端模块化开发，模块之间充分依赖的项目，都不值得用 Webpack 去构建。反之，如果要用 Webpack，请确保模块化，模块之间充分依赖。除此之外的构建工作，都应该交给 gulp 继续完成。目前大点的项目，Webpack 和 gulp 都是同时存在的，只是各自负责擅长的那部分，比如 Webpack 将模块的、互相依赖的分散的代码打包成数个文件，然后再使用 gulp 任务去做压缩，加版本号，替换等等其他工作。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">理解异步，手写Ajax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var getData = function()&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">      var xhr = new XMLHttpRequest()</span><br><span class="line">      xhr.open(&apos;GET&apos;,&apos;http://localhost:3000/arti/test&apos;,true)</span><br><span class="line">      xhr.onreadystatechange = function()&#123;</span><br><span class="line">        if(xhr.readyState == 4 &amp;&amp; xhr.status === 200)&#123;</span><br><span class="line">          resolve(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.send(null)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">git常用命令</p>
<table>
<tr>
	<td>克隆</td>
	<td>git clone</td>
</tr>
<tr>
	<td>查看日志</td>
	<td>git log</td>
</tr>
<tr>
	<td>回退到某个版本</td>
	<td>git reset --hard commit (309f***版本号***f8)</td>
</tr>
<tr>
	<td>切换分支</td>
	<td>git checkout _fz</td>
</tr>
<tr>
	<td>删除本地分支</td>
	<td>git branch -d _fz</td>
</tr>
<tr>
	<td>删除远程分支</td>
	<td>git push origin --delete _fz</td>
</tr>
<tr>
	<td>复制分支</td>
	<td>git checkout -b _new_fz</td>
</tr>
</table>
<br><br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue 路由</p>非懒加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import List from &apos;@/components/list.vue&apos;</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/list&apos;, component: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>懒加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法const list = () =&gt; import(&apos;@/components/list.vue&apos;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/list&apos;, component: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">//第二种方法</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/list&apos;, component: resolve =&gt; require([&apos;@/component/list&apos;],resolve) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数,<br>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。<br><span style="color:coral;">导航守卫</span><br>全局前置钩子:beforeEach（判断是否登录了，没登录就跳转到登录页),afterEach（跳转之后滚动条回到顶部）,beforeResolve（全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用）<br><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Vue3对比Vue2</p>我分别从代码、编译、打包三方面介绍vue3性能方面的提升<br>代码层面性能优化主要体现在全新响应式API，基于Proxy实现，初始化时间和内存占用均大幅改进（基于proxy: 初始化时懒处理，用户访问才做拦截处理）<br>编译层面做了更多编译优化处理，比如静态提升、动态标记、事件缓存，区块等，可以有效跳过大量diff过程；<br>打包时更好的支持tree-shaking，因此整体体积更小，加载更快。<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">滚动穿透</p>只加 overflow:hidden对移动端是无效的！<br><br>当body的高度被内容撑开而滚动时，如果不对body的高度加以限制，只加入 overflow:hidden，此时在移动端依然可以滚动。<br><br>我们可以在加入 overflow:hidden的同时选择性做：<br>将 html,body的高度设置为 100%将 html,body设置为绝对定位<br><br>这两个操作都可以完美地禁止整个body的滚动，但带来的最大问题是：<br>该方案会让浏览器的滚动条默认重置于初始位置<p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">React生命周期详解</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">React合成事件</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">v-for的key,react里的key</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">React Hooks详解</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">Diff算法详解</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">React Hooks详解</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">mobx原理，redux原理</p><p style="color:#ffb453bb;line-height:20px;margin-top:20px;font-weight:bold">问webpack怎么回答？</p>
                    
                    <!-- Tags Bottom -->
                    
                        <div class="tags-container-bottom">
                            <i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/学不完的js/">#学不完的js</a>
                        </div>
                    

                    <!-- Comments -->
                    



                </div>
                <div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50">
                    
                    <hr class="dn-l mw4 black-50 mt5">
                    
                    <!-- Widget 1: About -->
                    <div class="mt5 mt0-l">
    <article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3">
        <div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width: 6rem;">
            <img src="https://avatars.githubusercontent.com/u/49892998" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="gsnwjd王佳典">
        </div>
        <div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">
            永远期待参与到复杂项目中来  /  感谢你来看我的博客 :)  /  目前正在寻找合适的岗位
        </div>
    </article>
</div>

                    <hr class="dn-l mw4 black-50 mt5">
                    
                    <!-- Widget 2: Categories -->
                    

                    <!-- Widget 3: Recent Posts -->
                    <div class="mt5 tc tl-l">
    <h3>近期文章</h3>
    
        <p>
            <a href="/2022/04/01/Cocos-Creator初学：程序化控制帧动画/">Cocos Creator初学：程序化控制帧动画</a>
        </p>
    
        <p>
            <a href="/2022/03/16/关于学了又忘的TS/">关于学了又忘的TS</a>
        </p>
    
        <p>
            <a href="/2022/02/26/展示型Vue项目-·-细节拾取/">展示型Vue项目 · 细节拾取</a>
        </p>
    
        <p>
            <a href="/2022/02/22/word文件批量转化成统一模板/">word文件批量转化成统一模板</a>
        </p>
    
        <p>
            <a href="/2021/12/27/一小时聊完Less/">一小时聊完Less</a>
        </p>
    
</div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<div class="bg-1 ph2 ph5-ns pv5">
        <div class="mv8">
            <div class="center tc">
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://dribbble.com/" target="_blank">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://github.com/gsnwjd" target="_blank">
                            <i class="fa fa-github"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="pgldbm@foxmail.com" target="_blank">
                            <i class="fa fa-envelope"></i>
                        </a>
                    </div>
                
            </div>
            <div class="f6 f5-ns center tc white pt5 fw3">
                All right reserved | Design & Hexo <a class="link dim white" href="https://github.com/gsnwjd/">gsnwjd</a>
            </div>
        </div>
    </div>

<!-- After Footer -->
<!-- Disqus Comments -->



</body>

</html>